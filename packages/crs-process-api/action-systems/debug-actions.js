class v{static async perform(o,n,s,r){await this[o.action]?.(o,n,s,r)}static async start_monitor_events(o,n,s,r){const i=await crs.process.getValue(o.args.log,n,s,r);globalThis.__monitoredEvents={events:[],addedCount:0,removedCount:0},EventTarget.prototype.addEventListenerBase=EventTarget.prototype.addEventListener,EventTarget.prototype.addEventListener=function(e,t){i===!0&&console.log("Event added: ",{target:this,type:e,listener:t}),globalThis.__monitoredEvents.addedCount++,globalThis.__monitoredEvents.events.push({target:this,type:e,listener:t}),this.addEventListenerBase(e,t)},EventTarget.prototype.removeEventListenerBase=EventTarget.prototype.removeEventListener,EventTarget.prototype.removeEventListener=function(e,t){i===!0&&console.log("Event removed: ",{target:this,type:e,listener:t}),globalThis.__monitoredEvents.removedCount++,globalThis.__monitoredEvents.events=globalThis.__monitoredEvents.events.filter(a=>a.target!==this||a.type!==e||a.listener!==t),this.removeEventListenerBase(e,t)},console.log("Started monitoring events.")}static async stop_monitor_events(o,n,s,r){if(globalThis.__monitoredEvents===void 0){console.warn("No events are being monitored.");return}EventTarget.prototype.addEventListener=EventTarget.prototype.addEventListenerBase,EventTarget.prototype.removeEventListener=EventTarget.prototype.removeEventListenerBase,delete EventTarget.prototype.addEventListenerBase,delete EventTarget.prototype.removeEventListenerBase,globalThis.__monitoredEvents.addedCount!==globalThis.__monitoredEvents.removedCount?console.warn(`The number of added events does not match the number of removed events. This may indicate a memory leak. Added: ${globalThis.__monitoredEvents.addedCount}, Removed: ${globalThis.__monitoredEvents.removedCount}`):console.log("No event leaks found"),console.table(globalThis.__monitoredEvents.events),globalThis.__monitoredEvents=null,delete globalThis.__monitoredEvents}}crs.intent.debug=v;export{v as DebugActions};
