class w{static async perform(a,r,s,e){await this[a.action](a,r,s,e)}static async add(a,r,s,e){const t=await crs.process.getValue(a.args.target,r,s,e),l=await crs.process.getValue(a.args.value,r,s,e);t!=null&&l!=null?t.push(l):console.error(`can't add to array - array is null:${t==null}, value is null:${l==null}`)}static async move(a,r,s,e){const t=await crs.process.getValue(a.args.action,r,s,e),l=await crs.process.getValue(a.args.source,r,s,e),c=await crs.process.getValue(a.args.source_item,r,s,e),g=l.indexOf(c),u=await crs.process.getValue(a.args.target||l,r,s,e),n=await crs.process.getValue(a.args.target_item,r,s,e);if(l.splice(g,1),t==="append")return u.push(c);if(t==="prepend")return u.unshift(c);if(t==="insert"){const i=await crs.process.getValue(a.args.index,r,s,e);return u.splice(i,0,c)}if(t==="move_up"||t==="before"){const i=n!=null?u.indexOf(n):g;return u.splice(i-1,0,c)}if(t==="move_down"||t==="after"){const i=n!=null?u.indexOf(n):g;return u.splice(i+1,0,c)}}static async remove(a,r,s,e){const t=await crs.process.getValue(a.args.target,r,s,e),l=await crs.process.getValue(a.args.value,r,s,e),c=t?.indexOf(l);t!=null&&l!=null&&c!==-1?t.splice(c,1):console.error(`can't remove from array - array is null:${t==null}, value is null:${l==null}, value is not contained within target`)}static async transfer(a,r,s,e){const t=await crs.process.getValue(a.args.source,r,s,e),l=await crs.process.getValue(a.args.target,r,s,e),c=await crs.process.getValue(a.args.value,r,s,e);await this.add({args:{target:l,value:c}},r,s,e),await this.remove({args:{target:t,value:c}},r,s,e)}static async field_to_csv(a,r,s,e){const t=await crs.process.getValue(a.args.source,r,s,e);if(t==null)return console.error("fieldToCSV - target array does not exist");let l;const c=await crs.process.getValue(a.args.delimiter,r,s,e)||",";return a.args.field!=null?l=d(t,a.args.field,c):a.args.fields!=null&&(l=V(t,a.args.fields,c)),a.args.target!=null&&await crs.process.setValue(a.args.target,l,r,s,e),l}static async concat(a,r,s,e){let t=[];const l=await crs.process.getValue(a.args.sources,r,s,e);for(let c of l){let g=await crs.process.getValue(c,r,s,e);t=[...t,...g]}return a.args.target!=null&&await crs.process.setValue(a.args.target,t,r,s,e),t}static async change_values(a,r,s,e){const t=await crs.process.getValue(a.args.source,r,s,e),l=Object.keys(a.args.changes);let c={};for(let g of l)c[g]=await crs.process.getValue(a.args.changes[g],r,s,e);for(let g of t)for(let u of l)g[u]=c[u]}static async get_value(a,r,s,e){let l=(await crs.process.getValue(a.args.source,r,s,e))[a.args.index][a.args.field];return a.args.target!=null&&await crs.process.setValue(a.args.target,l,r,s,e),l}static async map_objects(a,r,s,e){const t=await crs.process.getValue(a.args.source,r,s,e)??[],l=a.args.fields??[];let c=[];for(const g of t){const u=await Promise.all(l.map(n=>crs.binding.utils.getValueOnPath(g,n)));c.push(...u)}return a.args.target!=null&&await crs.process.setValue(a.args.target,c,r,s,e),c}static async get_records(a,r,s,e){const t=[],l=await crs.process.getValue(a.args.source,r,s,e),c=await crs.process.getValue(a.args.page_number,r,s,e),g=await crs.process.getValue(a.args.page_size,r,s,e),u=await crs.process.getValue(a.args.fields,r,s,e);for(let n=c;n<c+g&&l[n]!=null;n++)if(u==null)t.push(l[n]);else{let i={};for(let f of u)i[f]=l[n][f];t.push(i)}return a.args.target!=null&&await crs.process.setValue(a.args.target,t,r,s,e),t}static async get_range(a,r,s,e){const t=await crs.process.getValue(a.args.source,r,s,e),l=await crs.process.getValue(a.args.field,r,s,e),c={min:Number.MAX_VALUE,max:Number.MIN_VALUE};for(let g of t){const u=g[l];u<c.min&&(c.min=u),u>c.max&&(c.max=u)}return a.args.target!=null&&await crs.process.setValue(a.args.target,c,r,s,e),c}static async calculate_paging(a,r,s,e){const t=await crs.process.getValue(a.args.source,r,s,e),l=await crs.process.getValue(a.args.page_size,r,s,e),c=Math.ceil(t.length/l);let g={row_count:t.length,page_count:c};return a.args.target!=null&&await crs.process.setValue(a.args.target,g,r,s,e),g}static async map_assign_data(a,r,s,e){const t=await crs.process.getValue(a.args.source,r,s,e),l=await crs.process.getValue(a.args.mappings,r,s,e),c=Object.keys(l),g=Object.keys(t[0]??{});for(const u of t)for(let n of c){let i=l[n];if(n=await crs.process.getValue(n,r,s,e),i=await crs.process.getValue(i,r,s,e),i==null){u[n]=null;continue}if(g.indexOf(i)==-1){u[n]=i;continue}u[n]=u[i]}return a.args.target!=null&&await crs.process.setValue(a.args.target,t,r,s,e),t}static async delete_properties(a,r,s,e){const t=await crs.process.getValue(a.args.source,r,s,e),l=await crs.process.getValue(a.args.properties,r,s,e);for(const c of t)for(const g of l)delete c[g]}}async function d(o,a,r){return o.map(e=>e[a]).join(r||",")}async function V(o,a,r){let s=[];for(let e of o){let t=[];for(let l of a)t.push(e[l]);s.push(t.join(r))}return s}crs.intent.array=w;export{w as ArrayActions};
