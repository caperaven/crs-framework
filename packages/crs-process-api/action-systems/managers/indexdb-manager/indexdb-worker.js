const d="_meta",m="meta_database",B=1;class p{#e;#t=null;#c=[];#s(t){if(t.length!==0)return this.#r(e=>{let r;for(const s of t)r=e.put(s,s.storeName);return r},"readwrite",d)}#n(t){return this.#r(e=>e.get(t),"readonly",d)}#o(t,e){return this.#r(r=>r.put(t,e),"readwrite",d)}#a(t,e=!0,r=!0){return this.#r(async s=>{for(const n of t){const a=s.get(n),c=await new Promise((i,o)=>{a.onsuccess=u=>{i(u.target.result)},a.onerror=u=>{o(u)}});e&&(c.count=0),r&&(c.timestamp=null),s.put(c,n)}},"readwrite",d)}connect(t,e,r,s){return new Promise((n,a)=>{this.#e=t;const c=[],i=self.indexedDB.open(this.#e,e);i.onerror=o=>{a(o.target.error)},i.onsuccess=async o=>{this.#t=o.target.result,await this.#s(c),w(t),n()},i.onupgradeneeded=o=>{const u=o.target.result;if(u.objectStoreNames.contains(d)===!1&&u.createObjectStore(d),r>0)for(let l=0;l<r;l++){const g=`table_${l<10?`0${l}`:l}`;u.createObjectStore(g).createIndex("idIndex","id",{unique:!0}),c.push({storeName:g,timestamp:null,count:0})}for(const l of s)u.objectStoreNames.contains(l)===!1&&(u.createObjectStore(l).createIndex("idIndex","id",{unique:!0}),c.push({storeName:l,timestamp:null,count:0}))}})}async disconnect(){this.#t&&(this.#t.close(),this.#t=null)}#r(t,e="readwrite",r){return new Promise(async(s,n)=>{const a=this.#t.transaction([r],e);a.onerror=o=>{n(o.target.error)};const c=a.objectStore(r),i=await t(c);i?(i.onsuccess=o=>(w(this.#e),s(o.target.result)),i.onerror=o=>n(o.target.error)):s()})}markNextTableAsUsed(){return new Promise((t,e)=>{const r=this.#t.transaction([d],"readwrite");r.onerror=a=>{e(a.target.error)};const s=r.objectStore(d),n=s.openCursor();n.onsuccess=async a=>{let c=a.target.result;do{const i=c.value,o=i.storeName;if(i.timestamp==null){const l=c.value;l.timestamp=new Date,s.put(l,o),t(o);break}}while(c.continue())},n.onerror=a=>{e(a.target.error)}})}getAvailableStore(){return new Promise(async(t,e)=>{const r=await this.markNextTableAsUsed().catch(s=>e(s));t(r)})}releaseStores(t){return new Promise(async(e,r)=>{Array.isArray(t)===!1&&(t=[t]),this.clear(t,!0,!0).then(()=>e()).catch(s=>r(s))})}set(t,e,r=!1){return new Promise(async(s,n)=>{t||=await this.getAvailableStore().catch(c=>n(c)),r==!0&&await this.clear([t],!0,!1).catch(c=>n(c));const a=await this.#n(t).catch(c=>n(c));await new Promise((c,i)=>{this.#r(async o=>{for(const u of e)await o.put(u,a.count),a.count+=1;c()},"readwrite",t).catch(o=>i(o))}),a.timestamp=new Date,await this.#o(a,t).catch(c=>n(c)),s(t)})}add(t,e,r){return this.#r(s=>{const n=r.count;return r.count+=1,s.add(e,n)},"readwrite",t)}addWithIndex(t,e,r){return this.#r(s=>s.add(e,r),"readwrite",t)}get(t,e){return this.#r(r=>r.get(e),"readonly",t)}update(t,e,r){return this.#r(s=>s.put(e,r),"readwrite",t)}deleteIndexes(t,e){return this.#r(r=>{Array.isArray(e)===!1&&(e=[e]);let s;for(const n of e)s=r.delete(n);return s},"readwrite",t)}deleteRange(t,e,r){return this.#r(s=>s.delete(IDBKeyRange.bound(e,r)),"readwrite",t)}async clear(t,e=!0,r=!0){await this.#a(t,e,r);const s=[];for(let n of t)s.push(this.#r(a=>a.clear(),"readwrite",n));return Promise.all(s)}getAll(t){return this.#r(e=>e.getAll(),"readonly",t)}getBatch(t,e,r){return new Promise((s,n)=>{const a=[],c=this.#t.transaction([t],"readonly");c.onerror=l=>{n(l.target.error)};const i=c.objectStore(t),o=IDBKeyRange.bound(e,r,!1,!1),u=i.openCursor(o);u.onsuccess=l=>{const f=l.target.result;f?(a.push(f.value),f.continue()):s(a)},u.onerror=l=>{n(l.target.error)}})}getRecordsByIndex(t,e){const r=e.map(s=>this.#r(n=>n.get(s),"readonly",t));return Promise.all(r)}getValues(t,e,r){return this.#r(s=>{const n=s.getAll(r);n.onsuccess=a=>a.target.result.map(o=>{const u={};for(const l of e)u[l]=o[l];return u})},"readonly",t)}hasKey(t,e){return this.#r(r=>r.getKey(e),"readonly",t)}getById(t,e){return new Promise(async(r,s)=>{const n=this.#t.transaction([t],"readonly");n.onerror=o=>{s(o.target.error)};const a=n.objectStore(t);Array.isArray(e)===!1&&(e=[e]);const c=a.index("idIndex"),i=[];for(const o of e)c.get(o).onsuccess=u=>{u.target.result!=null&&i.push(u.target.result)};n.oncomplete=()=>{r(i)}})}updateById(t,e){return new Promise(async(r,s)=>{Array.isArray(e)===!1&&(e=[e]);const n=this.#t.transaction([t],"readwrite");n.onerror=i=>{s(i.target.error)};const a=n.objectStore(t),c=a.index("idIndex");for(const i of e){const o=c.getKey(i.id);o.onsuccess=u=>{a.put(i,u.target.result)}}n.oncomplete=()=>{r()}})}deleteById(t,e){return new Promise(async(r,s)=>{const n=this.#t.transaction([t],"readwrite");n.onerror=i=>{s(i.target.error)};const a=n.objectStore(t),c=a.index("idIndex");Array.isArray(e)===!1&&(e=[e]);for(const i of e){const o=c.getKey(i);o.onsuccess=u=>{const l=u.target.result;a.delete(l)}}n.oncomplete=()=>{r()}})}getOldDatbaseNames(){return new Promise((t,e)=>{const r=self.db.transaction([d],"readonly");r.onerror=i=>{console.error(i.target.error)};const n=r.objectStore(d).openCursor(),a=[],c=Date.now();n.onsuccess=i=>{const o=i.target.result;if(o)do{const u=o.value.timestamp;c-u>duration&&a.push(o.key)}while(o.continue());t()}})}}class b{#e={};#t(t,e,r){return new Promise(async(s,n)=>{this.#e[e]===void 0&&n({uuid:t,success:!1,error:new Error(`Database ${e} is not connected`)}),await r().then(a=>{s({uuid:t,success:!0,data:a})}).catch(a=>{n({uuid:t,success:!1,error:a})})})}connect(t,e,r,s,n){return new Promise(async(a,c)=>{this.#e[e]!==void 0&&a({uuid:t,result:!0});const i=new p;await i.connect(e,r,s,n).catch(o=>{c({uuid:t,result:!1,error:o})}),this.#e[e]=i,a({uuid:t,result:!0})})}disconnect(t,e){return this.#t(t,name,async()=>{Array.isArray(e)===!1&&(e=[e]);for(const r of e)delete this.#e[r]})}getAvailableStore(t,e){return this.#t(t,e,async()=>await this.#e[e].getAvailableStore())}releaseStores(t,e,r){return this.#t(t,e,async()=>await this.#e[e].releaseStores(r))}set(t,e,r,s,n){return this.#t(t,e,async()=>await this.#e[e].set(r,s,n))}add(t,e,r,s){return this.#t(t,e,async()=>await this.#e[e].add(r,s))}clear(t,e,r,s,n){return this.#t(t,e,async()=>await this.#e[e].clear(r,s,n))}get(t,e,r,s){return this.#t(t,e,async()=>Array.isArray(s)===!1?await this.#e[e].get(r,s):await this.#e[e].getRecordsByIndex(r,s))}getAll(t,e,r){return this.#t(t,e,async()=>await this.#e[e].getAll(r))}getBatch(t,e,r,s,n,a){return this.#t(t,e,async()=>(n||=s+a-1,await this.#e[e].getBatch(r,s,n)))}deleteIndexes(t,e,r,s){return this.#t(t,e,async()=>await this.#e[e].deleteIndexes(r,s))}deleteRange(t,e,r,s,n){return this.#t(t,e,async()=>await this.#e[e].deleteRange(r,s,n))}getById(t,e,r,s){return this.#t(t,e,async()=>await this.#e[e].getById(r,s))}updateById(t,e,r,s){return this.#t(t,e,async()=>await this.#e[e].updateById(r,s))}deleteOldDatabase(t,e){return new Promise(async(r,s)=>{let n=await S(e).catch(o=>s(o));n.length===0&&r({uuid:t,success:!0,data:null}),n=n.filter(o=>this.#e[o]==null);const a=[];for(const o of n)await new Promise(u=>{const l=indexedDB.deleteDatabase(o);l.onsuccess=()=>{a.push(o),u()},l.onerror=f=>{console.error(f.target.error)}});const c=self.metaDB.transaction([d],"readwrite"),i=c.objectStore(d);for(const o of a)i.delete(o);c.oncomplete=()=>{r({uuid:t,result:!0})}})}deleteDatabase(t,e){return new Promise((r,s)=>{this.#e[e]!=null&&(this.#e[e].disconnect(),delete this.#e[e]);const n=indexedDB.deleteDatabase(e);n.onerror=a=>{s({uuid:t,success:!1,error:a.target.error})},n.onsuccess=()=>{const i=self.metaDB.transaction([d],"readwrite").objectStore(d).delete(e);i.onsuccess=()=>{r({uuid:t,success:!0,data:null})},i.onerror=o=>{s({uuid:t,success:!1,error:o.target.error})}}})}deleteById(t,e,r,s){return this.#t(t,e,async()=>await this.#e[e].deleteById(r,s))}}function S(h){return new Promise(async(t,e)=>{const r=[],s=self.metaDB.transaction([d],"readonly"),n=s.objectStore(d),a=new Date,c=n.openCursor();c.onsuccess=async i=>{let o=i.target.result;for(;o;){const u=o.key,l=o.value.timestamp;a-l>h&&r.push(u),o=o.continue()}},s.oncomplete=()=>{t(r)}})}function A(){return new Promise((h,t)=>{const e=self.indexedDB.open(m,1);e.onerror=r=>{t(r.target.error)},e.onsuccess=async r=>{self.metaDB=r.target.result,h()},e.onupgradeneeded=r=>{r.target.result.createObjectStore(d)}})}function w(h){const t=self.metaDB.transaction([d],"readwrite");t.onerror=r=>{console.error(r.target.error)},t.objectStore(d).put({timestamp:new Date},h)}const y=[];A().then(()=>{self.manager=new b;for(const h of y)self.onmessage(h)}).catch(h=>console.error(h)),self.onmessage=async function(h){if(self.manager==null){y.push(h);return}const t=h.data.action,e=h.data.args,r=h.data.uuid;self.manager[t]&&await self.manager[t](r,...e).then(s=>self.postMessage(s)).catch(s=>self.postMessage(s))};
